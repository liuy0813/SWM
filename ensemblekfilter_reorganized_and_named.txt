%       Created by Dwight Nwaigwe  April 2011
%	This program uses the ensemble kalman filter to estimate a system's state.
%	The state is x_new=f(x,u)+w, where u some input, w the
%	Gaussian distributed process noise, and f is a nonlinear function. The measurement 
%	is y_new=h(x)+v where h is a nonlinear function and v Gaussian distributed measurement noise.                 


%       The algorithm used in this code is referenced from the following:
%       S Gillijns et. al., "What Is the Ensemble Kalman Filter and How Well Does it Work?"
%       Proceedings of the 2006 American Control Conference,
%       Minneapolis, Minnesota, USA, June 14-16, 2006, pp 4448-4453.


%      Example

%      The state and measurement in this example  is taken from Dan Simon, "Kalman Filtering", 
%      Embedded Systems Programming,2001.
%       
%
%	syms  x1 x2;   %variables must be named x1...xn
%	f=[x1+.1*x2+.005;x2+.1];
%	h=[x1];
%	x_true=[1;1]; %initial value of state
%	x_initial=ones(2,20); %ensemble of initial estimate of the state; 20 is the number of members
%	w=[10^-3; .02];  %process noise standard deviation
%	z=[10];  %measurement noise standard deviation
%	num_iterations=600;
% 	[a,b,c]=ensemblekfilter(f,h,x_true,x_initial,w,z,num_iterations);




function [x_true,x_estimatebar,ybar]= ensemblekfilter(f,h,x_true,x_initial,w,z,num_iterations) 



[dummy,num_members]=size(x_initial);
p1=length(f);
m1=length(h);
var_vector=[];
xvec=[];
x_estimate_vec=[];
yvec=[];
x_estimate=x_initial;

for j=1:p1  %create vector containing variables x1 to xn
  eval(sprintf(' syms x%d', j));
  var_vector=[var_vector sprintf('x%d ',j)];
  end

var_vector=strcat('[',var_vector);
var_vector=strcat(var_vector,']');

Zcov=eye(m1); %create measurement noise covariance matrix

for j=1:m1
  Zcov(j,j)=z(j)^2;
end


for i=1:num_iterations  

   x_true=subs(f,var_vector,x_true)+w.*randn(p1,1); %compute true value of state at next time step
   
   for j=1:num_members
     W(:,j)=w.*randn(p1,1);                          %create process noise
     Z(:,j)=z.*randn(m1,1);                          %create measurement noise
     x_estimate(:,j)=subs(f,var_vector,x_estimate(:,j))+W(:,j);      %forecast state
     y(:,j)=subs(h,var_vector,x_true)+Z(:,j);                 %make measurement
     y_forecast(:,j)=subs(h,var_vector,x_estimate(:,j));              %forecast measurement
   end

   x_estimatebar=mean(x_estimate,2);                    
   ybar=mean(y,2);
   y_forecastbar=mean(y_forecast,2);

   for j=1:p1
     Ex(j,:)=[x_estimate(j,:)-x_estimatebar(j)];
   end

   for j=1:m1
     Ey(j,:)=[y_forecast(j,:)-y_forecastbar(j)];
   end

   Pxy=Ex*Ey'/(num_members-1);
   Pyy=Ey*Ey'/(num_members-1)+Zcov;                     %The addition of Zcov to Pyy is not done in Gillijns et. al but I use it here in case num_members=2 or Pyy is nearly singular
   K=Pxy*inv(Pyy);
   x_estimate=x_estimate+K*(y-y_forecast);
   xvec=[xvec x_true];
   x_estimate_vec=[x_estimate_vec x_estimatebar];
   yvec=[yvec ybar];
   if i==num_iterations
   x_estimatebar=mean(x_estimate,2);
   end
end
